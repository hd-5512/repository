首先建立这样一个概念

Redis所有的底层数据结构都是一个对象 就是一个类 它有成员属性和成员方法

并且Redis的数据库都是以字典类型作为结构来存储的

## 简单动态字符串 SDS : Simple Dynamic String
#### SDS对象中的结构
- free:记录SDS中是否有未使用的空间
- len:已使用的空间 (不含空字符)
- buf:char类型的数组 用来存放字符  最后以空字符 '\0' 结束

因为redis使用c编写 这样就可以直接使用c的库 比如在打印字符串时的命令 printf("%s",sds->buf) 


#### 相比C语言的字符串  SDS的优势

- 对象化的SDS 在获取长度时的复杂度O(1) 而C则需要一个一个去计数O(n)

- 杜绝了缓冲区溢出问题 buffer overflow  每次增长或缩短一个c字符串 都需要对它进行一次内存重新分配，如果没有做就可能会产生缓冲区溢出或内存泄露 损坏了数据 或 浪费了内存
    1. 因为c不记录字符串长度 所以执行strcat将src写入dest尾部时 就需要考虑dest是否已经分配了足够多的内存

    2. 打个比方 s1 和 s2 连续存储在一起  因为s1溢出 而覆盖s2会使s2的数据被意外修改

    3. 而SDS有自己的空间分配策略 在拼接和修改前快速读取长度并扩展足够的空间

- Redis对于速度的要求严苛、数据可能被频繁修改 c语言中的CPU损耗要高于SDS
    1. 因为执行内存重分配的时间占修改字符串中的比例很高 
    2. 为了避免这种缺陷 减少重分配 free 的作用就发挥出来了

##### SDS实现了空间预分配和惰性空间释放
- 空间预分配：
    1. 如果对SDS进行修改，SDS->len < 1MB，那程序就分配给free和len一样的空间，比如修改后SDS->len=13，那么SDS->buf里面内容是 13+1+13=27字节
    2. 修改后len >= 1MB,那么就再分配1MB的未使用空间，30MB+1byte+1MB
    3. 这样每次执行修改前只需要判断空间是否足够，可以减少内存重分配的次数
- 惰性空间释放:
    1. 在使用一些函数直接减小SDS时不会释放空间，而是保留到free中，为以后可能得增加保留空间
    2. 再次修改就可能不需要内存的重分配了
    3. SDS也提供了相印的API让我们在有需要时候正真的释放SDS的未使用空间


##### 存储策略
- 二进制安全:
    1. 因为有len 所以SNS的支持除了文本以外的内容存储 它不会只因为'\0'空字符而判断内容的结束
    2. SDS的API都以处理二进制方式来执行 不会过滤或者限制，写入时什么样子，读取时就是什么样子


## 链表 
#### 链表的结构
- 节点 有 value prev next 三个属性
- 链表 有 head tail len 三个属性 以及 节点dup赋值 free释放 match对比三个函数
#### 特点
- 快速：获取头结点或者尾节点以及前后节点还有长度的复杂度都是O(1) 
- 无环：表头和表尾都是 NULL  
- 一个链表里可以存放不同类型的值



## 字典
字典的实现时HashTable
##### 哈希算法
##### 解决键冲突 collision 使用separate chaining 就是变成一个链表 最新的放头部
##### Rehash ht0外还需要ht1的原因
- 如果是执行扩展操作 ht1 为大于等于 ht0.used * 2 的 2的n次方 比如一个hash里used=5  5*2 = 10 > (8)2^3那么ht1就是(16)2^4
- 如果是收缩操作 ht1 为大于等于 ht0.used 的 2的n次方
- rehash 后 ht0 变成空表  ht0 = ht1 再释放ht1  关键字负载因子 = used/size < 0.1时自动收缩







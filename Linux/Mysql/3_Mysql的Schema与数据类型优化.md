## 如何选择优化的数据类型

- 尽量使用可以正确存储数据的最小数据类型 

        更小的数据类型通常更快、因为他们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少
        
        比如 数据值范围在 0-200 时 选择tinyint unsigned 比较合适 

        TINYINT     1 byte   -128 ~ 127  1 byte = 8 bit（2^8)
        SMALLINT    2 byte   
        MEDITUMINT  3 byte
        INT         4 byte
        BIGINT      8 byte
        
- 使用简单数据类型   数字、字符串、时间(date,time,datatime)

        整型比字符串操作代价更低，就需要更少的CPU周期
        因为字符集和校对规则、排序规则使得字符串的比较更加复杂
        
        常见优化比如 
        1. 应该使用Mysql内建类型而不是使用字符串来存储时间和日期
        2. 应该用整型存储IP地址而不是字符串
        
- 尽量避免NULL

        表的设计默认值最好使用 NOT NULL 除非真的需要存储 NULL 值
        1. 如果查询中包含可为 NULL 的列时， Mysql很难去优化查询速度，因为可为NULL的列使得使用索引、统计索引、值比较都更加复杂
        2. 可为NULL的列也会使用更多的存储空间(主要建立索引时)
        3. 虽然NULL 改成 NOT NULL 对性能带来的提升比较小，但是设计时应当注意这个问题 特别当由计划在这个列上建索引时
        4. 例外情况 InnoDB使用单独的位bit存储NULL值，所以对于稀疏数据(很多值为NULL，少数有非NULL值)有很好的空间效率，但是不适于MyISAM


### 数字类型

- 有无符号属性，区别只是控制了正数的上限提高一倍，具有相同的性能
    
- INT(M) 中的M指的是 显示用的长度(特别在和fillzero配合使用还有其他交互client工具使用时由作用而已) 和 存储的值范围没有任何关系
    
- DECIMAL用户存储精确小数 Mysql将数字打包保存进入一个二进制字符串中 每4个字节可以存储9个数字 小数点独自占一个字节

        DECIMAL(18,9) 表示 两边9个数字  4字节 * 2 + 小数点 = 9 字节
        
        DECIMAL 在Mysql中允许最多 65个数字 65/9 = 7 * 4 = 28 字节 以上 要远大于 BIGINT 8 byte

### 字符串类型

    字符集 、 排序规则 或者说 校对规则(collation) 这些东西会很大程度上的影响性能
    
    更小的空间分配被证明会有很大优势，更长的列会消耗更多内存，因为Mysql会分配固定大小的内存块来保存内部值，特别在使用内存零时表来进行排序或操作，磁盘页同样。
    
- VARCHAR    
    1. VARCHAR 相比 CHAR 定长 更节省空间，仅使用必要的空间
    
    2. 数据结构的存储是内容+长度  需要额外的空间存储内容的长度 
    
            如果列的最大长度在(0-255 byte)使用1byte，超过是使用2byte
            
            所以 VARCHAR(10) 最大需要11字节的空间 而 VARCHAR(1000)需要1002字节
            
    3. 空间节省有很好的性能帮助 但是行是变长的，如果比原来更长自然会导致额外的工作，另外如果存储的页内没有更多空间，可能就要拆分存储
    
    4. 使用VARCHAR的合适情况: 字符串列的最大长度比平均长度大很多 列的更新很少(所以碎片不是问题) 使用了UTF-8这类复杂的字符集，每个字符可能使用不同的字节数进行存储
    
- CHAR
    1. 定长特点 总是根据定义的长度分配足够的空间
    
    2. 当存储CHAR值时，Mysql会删除所有的末尾空格 比如 'string    ' =》 'string' 而 VARCHAR 会保留空格
   
    3. CHAR适合存储很短的字符串 所有值都接近一个长度的 比如MD5后的结果  不容易产生碎片 在存储空间上更有效率
    
    4. 字符串长度是字符数 不是 字节数
    
- BLOB 和 TEXT 
    
        区别是BLOB使用二进制存储  TEXT使用字符串方式存储
        
        排序政策不同 只对每个列的最前max_sort_lenth『字节』而不是字符进行排序 因为无法对全部长度进行索引
        
        同样对于 VARCHAR(1000) 的列 1000万行的表，utf8=>每个字符3字节，最坏情况 3000字节的空间，如果要进行排序并且查询扫描整个表 光为排序就需要超过30GB的零时表
        
        在这时使用TEXT和BLOB变有一定的优势  但是还是建议不要使用
        
- 使用ENUM代替字符串类型

       存储枚举时使用映射关系，非常紧凑，内部将每个值在列表中保存为整数
       
       CREATE TABLE enum_test(
        e ENUM('B','A','C') NOT NULL     // A -1   B -2  C-3
       )
      
       避免把数字设置在枚举中可能会出现双重性导致混乱 如果使用 2 1 3 作为值就会出现异常
       
       排序默认就是按照 Mysql内部存储的值来 而不是字符串 如果想要绕过 就只能使用自定义 ORDER BY FIELD（e,'A','B','C'）
       
       但是这会导致Mysql无法利用索引消除排序
       
       枚举最不好的地方是，字符串列表是固定的，未来可能改变的字符串不适合使用枚举
       
       但是枚举不适合关联字符串，除非都使用整数或枚举进行关联  特别是主键，不仅列转换ENUM后可以缩小1/3，作为主键索引也会相应变小
       
- 时间和日期类型

        DATETIME     TIMESTAMP 的区别
        
        TIMESTAMP 保存时间区间比较小 存储内容为时间戳  它依赖时区 每次插入和更新时如果你不指定 mysql也会生成第一个时间就是当前时间 默认NOT NULL 和其他数据类型有一些不同
        
        FROM_UNIXTIME() 时间戳转日期
        
        UNIX_TIMESTAMP() 日期转时间戳
        
        DATETIME 保存时间区间更长 存储为 "2008-01-16 22:01:24" 标准的ANSI格式 在Mysql中它是可排序无歧义的值 使用8个字节来存储
        
        
        TIMESTAMP 比 DATETIME空间效率更高
        虽然可以把时间戳存为整数，用整数保存的格式不方便处理不被推荐
        
- 位数据类型

        技术上来讲都是字符串类型
        
        使用紧凑的位存储数据        
                
        
        
        
               
       

    

       
    
    
    

































  
        
        
## 如何选择优化的数据类型

- 尽量使用可以正确存储数据的最小数据类型 

        更小的数据类型通常更快、因为他们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少
        
        比如 数据值范围在 0-200 时 选择tinyint unsigned 比较合适 
        
        使用unsigned也可以很大程度上的在预估数值范围状态下减少空间不足修改结构的风向
        
        TINYINT     1 byte   -128 ~ 127  1 byte = 8 bit（2^8)
        SMALLINT    2 byte   
        MEDITUMINT  3 byte
        INT         4 byte
        BIGINT      8 byte
        
        通常在表初期根据业务优化Schema结构，这很重要，在设计时的预估将会在早期得到印证，这时进行检查是必要的。
        
- 使用简单数据类型和内建类型   数字、字符串、时间(date,time,datatime)

        整型比字符串操作代价更低(因为字符集有复杂的校对/排序规则)，操作时需要更少的CPU周期
        因为字符集和校对规则、排序规则(collation)使得字符串的比较更加复杂
        
        常见优化比如 
        1. 应该使用Mysql内建类型而不是使用字符串来存储时间和日期
        2. 应该用整型存储IP地址而不是字符串 
                INET_ATON() / INET_NTOA 可以直接转换
        
- 尽量避免NULL

        表的设计默认值最好使用 NOT NULL 除非真的需要存储 NULL 值
        1. 如果查询中包含可为 NULL 的列时， Mysql很难去优化查询速度，因为可为NULL的列使得使用索引、统计索引、值比较都更加复杂
        2. 可为NULL的列也会使用更多的存储空间，特别是含NULL列建立索引时 每个索引记录都需要一个额外的字节 MyISAM中固定大小的索引(比如整数列的索引)变成可变索引
        3. 虽然NULL 改成 NOT NULL 对性能带来的提升比较小，但是设计时应当注意这个问题 特别当由计划在这个列上建索引时
        4. 例外情况 InnoDB使用单独的位bit存储NULL值，所以对于稀疏数据(很多值为NULL，少数有非NULL值)有很好的空间效率，但是不适于MyISAM


### 数字类型

- unsigned 多用有无符号属性，区别只是控制了正数的上限提高一倍，具有相同的性能
    
- INT(M) 中的M指的是 客户端显示用的长度 存储的值范围与计算没有任何关系
    
- DECIMAL用户存储精确小数 Mysql将数字打包保存进入一个二进制字符串中 每4个字节可以存储9个数字 小数点独自占一个字节

        DECIMAL(18,9) 表示 两边9个数字  4字节 * 2 + 小数点 = 9 字节
        
        DECIMAL 在Mysql中允许最多 65个数字 65/9 = 7 * 4 = 28 字节 以上 要远大于 BIGINT 8 byte
        
        DECIMAL 比较精准 但是实际类似字符串 FLOAT 和 DOUBLE 计算上更快很多但是因为精度问题可能出一些奇怪的结果
        
        适合存储财务数据
        
        但是也可以使用 BIGINT 来替代 DECIMAL 只要能确定计算精确度的情况下
        
        使用 1000 来代替 0.001 可以同时解决精度问题 还能避免DECIMAL计算代价高问题

### 字符串类型

    更小的空间分配被证明会有很大优势，更长的列会消耗更多内存，因为Mysql会分配固定大小的内存块来保存内部值，特别在使用内存零时表来进行排序或操作，磁盘页同样。
    
- VARCHAR    
    1. VARCHAR 相比 CHAR 定长 更节省空间，仅使用必要的空间
    
    2. 数据结构的存储是内容+长度  需要额外的空间存储内容的长度 
    
            如果列的最大长度在(0-255 byte)使用1byte，超过是使用2byte
            
            所以 VARCHAR(10) 最大需要11字节的空间 而 VARCHAR(1000)需要1002字节
            
    3. 不适合经常更新,尤其是一会儿很长,一会儿很短的内容 容易造成碎片 
    
    4. 对空间节省有很好的性能帮助 但是行是变长的，比原本最长的内容还长时 
       如果比原来更长自然会导致额外的工作，存储的页内没有更多空间，可能就要拆分存储，结果就是乾坤那挪移或是大搬家
    
    5. 使用VARCHAR的合适情况: 字符串列的最大长度比平均长度大很多 列的更新很少(所以碎片不是问题) 使用了UTF-8这类复杂的字符集，每个字符可能使用不同的字节数进行存储
    
- CHAR
    1. 定长特点 会用采用空格去进行填充 读取时又会删除末尾空格
   
    2. CHAR适合存储很短的字符串 所有值都接近一个长度的 比如MD5后的结果  不容易产生碎片 在存储空间上更有效率
    
    3. 字符串长度是字符数 不是 字节数
    
- BLOB 和 TEXT 
    
        区别是BLOB使用二进制存储  TEXT使用字符串方式存储
        
        排序政策不同 只对每个列的最前max_sort_lenth『字节』而不是字符进行排序 因为无法对全部长度进行索引
        
        同样对于 VARCHAR(1000) 的列 1000万行的表，utf8=>每个字符3字节，最坏情况 3000字节的空间，如果要进行排序并且查询扫描整个表 光为排序就需要超过30GB的零时表
        
        在这时使用TEXT和BLOB变有一定的优势  但是还是建议不要使用
        
- 使用ENUM代替字符串类型

       1.存储枚举时使用映射关系，非常紧凑，内部将每个值在列表中保存为整数
       
       CREATE TABLE enum_test(
        e ENUM('B','A','C') NOT NULL     // B = 1   A = 2  C= 3
       )
      
       避免把数字设置在枚举中 '2','1','3' 实际存储可能是 '2' = 1  '1' = 2 '3' = 3
       可能会出现双重性导致混乱
       
       2.ENUM的索引和排序也是根据内部存储的整数 而非外部的字符串
       
       如果想要绕过 就只能使用自定义 ORDER BY FIELD（e,'A','B','C'）
       
       但是这这样做就会导致Mysql无法利用索引消除排序
       
       3.枚举最不好的地方是，字符串列表是固定的，未来可能改变的字符串不适合使用枚举，最多的改变是在末尾添加最新的值
       
       4.枚举不适合关联字符串，除非都使用整数或枚举-枚举进行关联  特别是主键，不仅列转换ENUM后可以缩小1/3，作为主键索引也会相应变小
       
- 时间和日期类型

        TIMESTAMP 的区别
        
        TIMESTAMP 只使用 DATEIMTE 一半的存储空间 且 可以利用时区自动更新
        
        但是TIMESTAMP 可保存时间区间是有限的 存储内容为时间戳 依赖时区特殊性也会带来一些问题 
        
        #每次插入和更新时如果你不指定 mysql也会生成第一个时间就是当前时间 默认NOT NULL 和其他数据类型有一些不同
        
        DATETIME  
        
        
        FROM_UNIXTIME() 时间戳转日期
        
        UNIX_TIMESTAMP() 日期转时间戳
        
        DATETIME 保存时间区间更长 存储为 "2008-01-16 22:01:24" 标准的ANSI格式 在Mysql中它是可排序无歧义的值 使用8个字节来存储
        
        
        TIMESTAMP 比 DATETIME空间效率更高
        虽然可以把时间戳存为整数，用整数保存的格式不方便处理不被推荐
        
### 一些实际操作中的问题

       
   - 太多的列   
   
    MYSQL的存储引擎API工作时 需要在 上面服务层 和 存储引擎层之间 通过缓冲格式拷贝数据
    也就是说 然后服务器将缓冲内容解码成各个列 
    除了MYISAM引擎的定长字符串列不需要转换外，其他 变长行结构 以及 InnoDB行结构都需要转换，性能依赖于列的数量
   
   - 
                 
        
        
        
               
       

    

       
    
    
    

































  
        

## Mysql的逻辑架构

#### Mysql最重要、最与众不同的特性是他的存储引擎架构

- Mysql被设计成将 查询处理(Query Processing) 以及其他系统任务(Server Task)   和  数据存储/提取 相分离的模式

#### Mysql的逻辑架构分成三层

- 第一层 客户端 它是最上层 主要功能和大多数的C/S系统类似:连接处理、授权认证、安全等等

        安全政策是优先通过 用户名 主机信息 密码进行验证 建立连接
        
        连接成功后 再继续验证 对某个数据库是否有SELECT权限等

- 第二层 服务器端 核心服务功能(查询解析、分析、优化、缓存 所有内置函数、存储过程、触发器、视图等)
所有跨存储引擎的功能都在这一层 类似是一个 MVC中的controller 

- 第三层 存储引擎 负责Mysql中数据的存储和提取 

        数据库服务器(Mysql Server程序)通过API与存储引擎进行通信，这些API比如『开始一个事务』『根据主键提取一行记录』等

        但是 一般情况下存储引擎不会去解析SQL 不同存储引擎之间不会相互通信 只是简单地响应上层服务器的请求

        (InnoDB例外 它会解析外键 因为Mysql服务器本身没有实现该功能)


#### 连接管理

- 每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，而这个线程只能轮流在某个CPU核心或者CPU中运行。
   
        服务器会负责缓存线程 因此不需要为每个新建的连接创建或者销毁线程
        
        Mysql 5.5 或者更新的版本 提供了一个API 支持线程池Thread-Pooling插件 可以使用池中少量的线程来服务大量的连接 
        
        这里可以发现 连接池中的连接数并非越大越好  因为他们都依赖CPU 过多的连接数也无法同时进行运行 而是通过系统内核的调用 时分复用 通过上下文切换来轮流逐个执行 

        如此过多的连接数在轮流执行过程中会产生很多额外的系统I/O的而带来不必要的性能消耗


#### 优化与执行

- Mysql会解析查询并创建内部数据结构 (解析树) 然后对它进行各种优化 比如重写查询、决定表的读取顺序、选择合适的索引等

- 用户可以通过特殊的关键字来 提示 优化器 影响它的决策过程
        
        优化解释器 Explain 




- 对于SELECT语句 在解析查询之前 服务器优先检查查询缓存(Query Cache)
    
        如果在里面可以找到对应的查询 就不必再去执行查询解析、优化和执行的整个过程
    
        可以直接返回查询缓存中的结果集


#### 并发控制

- 并发指多个查询需要在同一时刻修改数据，Mysql需要分服务器层和存储引擎层两个层面区讨论

- 通过锁来控制并发问题  读锁read lock(共享锁) && 写锁write lock(排它锁)
        
        1. 读锁：为了解决复杂的场景中 当A正在读取 B缺要修改时产生
        
            读锁允许多个客户在同一时间读取同一个资源而不不干扰(相互不阻塞)
            
        2. 写锁:阻塞其他所有的写锁和读锁，确保只有一个用户在使用该资源
        
- 锁粒度 在给定的资源上，锁定的数据量越少越精准，系统的并发程度就越高。

        1.锁策略：需要考虑的是加锁也需要消耗资源。锁的操作包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统开销。
        锁的开销和数据安全性之间寻求平衡。
        
        2.表锁：Mysql最基本也是开销最小的策略，在写入时阻塞整张表，而没有写锁时读锁之间不会有阻塞
        
        写锁比读锁有更高的优先级，甚至可以插入到读锁队列的前面，尽管存储引擎可以管理自己的锁，但Mysql服务器本身就会使用表锁，而忽略存储引擎的锁机制
        
        3.行级锁:最大程度地支持并发，同时也带来最大的锁开销
        
        行级锁是存储引擎实现的，如InnoDb,Mysql服务层本身没有实现。
        
#### 事务:运行良好的事务具备 ACID 原子性 一致性 隔离性 持久性

- 隔离级别 越低支持更高的并发，开销也低，但是数据安全性弱
    1. 未提交读 READ UNCOMMITTED
        
            事务中的修改，没有提交，对其他事务夜市可见的，而事务读取未提交数据被称为脏读，不推荐使用 
    2. 提交读 READ COMMITTED
   
            多数数据库采取的级别，一个事务从开始到提交前，所做的修改对其他事务不可见，也叫不可重复读，因为两次执行相同的查询可能会得到不一样的结果
    3. 可重复读 REPEATABLE READ
    
            同一个事务中多次读取同样记录的结果是一致的，解决了脏读问题
            
            但是当某事务读取某范围内的记录，另外事务又在里面插入新记录，再读取范围时，会产生幻行问题
            
            这个是Mysql的默认事务隔离级别
    
    4. 可串行化 SERIALZABLE
    
            最高隔离级别，强制事务串行执行，单通道阻塞
            
            读取的每一行数据上都加锁，性能受到很大的影响，只有在非常需要确保数据的一致性而且可以接受没有办法的情况下，才考虑使用
    
- 死锁

        两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而相互等待。
        
        InnoDB可以检测，并立即返回一个错误，避免导致非常慢的查询
        
        另外一种方案时锁等待超时，将持有最少行级排他锁的事务进行回滚(死锁回滚法)
        
        应用程序在设计Ⅹ必须考虑如何尽量避免死锁和如何处理死锁，多数情况下需要重新执行因锁死回滚的事务即可
        
 - 事务日志
 
        事务日志可以帮助提高事务的效率。
        
        使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。
        
        事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以这意味着采用事务日志方式相对来说要快得多
        
        事务日志持久化后，内存中被修改的数据在后台可以慢慢地刷回磁盘。
        
        目前多数的存储引擎时这样实现的，预写式日志(Write-Ahead Logging),修改数据需要写两次磁盘
        
        如果数据的修改已经记录到事务日志并持久化，但是数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动回复这部分修改的数据。具体方式依存储引擎而定
 
 
- Mysql中的事务

  1. 自动提交
  
            Mysql默认采用自动提交模式，每个查询都被当做一个事务来执行操作
            
            SHOW VARIABLES LIKE 'AUTOCOMMIT'可查看 SET ... = 1/0 修改
            
            如果关闭，每个查询都需要等到手动执行COMMIT or ROLLBACK
            
            同理 隔离级别都可以用SET 修改
            
            不建议混合MyISAM和InnoDB使用事务，因为回滚时 MyISAM的变更无法撤销
            
  2. 隐式和显式锁定
  
            隐式：InnoDB在事务执行过程中，随时都在执行锁定，只有在COMMIT/ROLL的时候才会释放并且是所有同时释放
            
            显式：InnoDB也支持通过特定的语句(不属于SQL规范) SELECT ... LOCK IN SHARE MODE / SELECT ... FOR UPDATE


- MVCC 多版本并发控制

    1. 概念
           
            可以认为MVCC是行级锁的一个变种，不同的数据库可能有不同的机制，但是它在很多情况下避免了加锁操作，降低开销
        
            目的：实现非阻塞的读操作，写操作也只锁定必要的行
        
    2. 实现方式
            
            Mysql中的MVCC实现时通过保存数据在某个时间点的快照来实现：        
            1. 不管需要执行多久，每个事务里面看到的数据都是一致的。 
            2. 事务开始时间不同，他们即使是在同一张表上，同一个时间执行看到的数据可能也是不一样的。
            
            InnoDB的MVCC通过在每行记录后面保存两个隐藏的列来实现：
            1. 一个列字段保存了行 的 创建时间  另一个存储行的过期/删除时间
            2. 这个时间其实不是真实的时间值，而是系统版本号，每开始一个事务，系统版本号都会自动递增
            3. 事务开始时刻的版本号会作为事务版本号，用来和查询到的每行记录的版本号进行比较
            
            SELECT 分别根据新加的两个字段进行检查
                    行版本号应该是小于等于当前事务的系统版本号，这样保证数据时之前或本次事务内修改
                    删除版本号要么未定义，要么大于当前事务版本号，表明在事务开始前未被删除
            
            INSET  InnoDB为新插入的每一行都保存当前系统版本号作为行版本号
            
            DELETE InnoDB为删除的每一行保存当前系统版本号作为删除标识
            
            UPDATE InnoDB为插入一行新记录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识
            
            保存着两个额外系统版本号，使大多数读操作都可以不用加锁，减少读上的性能开销，并且还能保证只读取到符合标准的行
            
            不足之处就是需要额外的存储空间、更多的行检查工作等
            
            MVCC只能在 REPAETABLE READ 和 READ COMMITTED 两个隔离级别下工作
            
 
              
        



















        
            
           
         
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
             
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
        
      



    
   
        
                
        

                
        
        
        
        
        
        
        
        
        
        
        































；





















 






